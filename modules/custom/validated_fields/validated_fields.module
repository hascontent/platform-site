<?php

/**
 * @file
 * Contains validated_fields.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\validated_fields\Entity;

/**
 * Implements hook_help().
 */
function validated_fields_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the validated_fields module.
    case 'help.page.validated_fields':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Entities built on paragraphs meant to field content with custom validations and permissions on each field') . '</p>';
      return $output;
    default:
  }
}

function validated_fields_install(){
  $defs = \Drupal::service('plugin.manager.field.field_type')->getDefinitions();
  $forbidden_fields = ["file_uri" => TRUE, "uuid" => TRUE, "path" => TRUE, "map" => TRUE, "created" => TRUE, "changed" => TRUE, "comment" => TRUE, "password" => TRUE, "language" => TRUE, "uuid" => TRUE, "entity_reference" => TRUE];
  foreach($defs as $field_name => $field_type){
    if($forbidden_fields[$field_name] === TRUE || strpos($field_name, "list") !== false){
      continue;
    }
    $field_store_type = \Drupal::EntityTypeManager()->getStorage('field_store_type')->create(
      array(
        "label" => $field_name,
        "id" => $field_type["id"]
      )
    );
    $field_store_type->save();
    $field_storage = \Drupal::EntityTypeManager()->getStorage('field_storage_config')->create(array(
      "field_name" => $field_type["id"],
      "type" => $field_type["id"],
      "entity_type" => "field_store"
    ));
    $field_storage->save();

    $field_config = \Drupal::EntityTypeManager()->getStorage("field_config")->create(array(
      "field_storage" => $field_storage,
      "bundle" => $field_store_type->id
    ));
    $field_config->save();
  }
    $category = \Drupal::EntityTypeManager()->getStorage('taxonomy_term')->create(["vid" => "field_categories", "name" => "default"]);
    $category->save();
    $vft = \Drupal::EntityTypeManager()->getStorage("validated_field_type")->create(["field_type" => "text", "category" => "default", "name" => "default text"]);
    $vft->save();
    
}

function validated_fields_entity_type_alter( &$entity_types){
  $entity_types['validated_field']->addConstraint('ConstraintCollection');
  $entity_types['validated_field_type']->addConstraint('ConstraintCollection');
}

/////////////////////////////////////////////////////////////
// ENTITY CRUD HOOKS

function validated_fields_field_store_update($entity){
  $foo = 'bar';
}

function validated_fields_validated_field_insert($entity){
  $storageType = $entity->getStorageTypeId();
  $storage = \Drupal::entityTypeManager()->getStorage('field_store')->create(["type" => $storageType]);
  $storage->validated_field = $entity;
  $storage->save();
  $entity->storage = $storage;
  if($entity->validations->getValue() === []){
    $entity->validations = $entity->field_type->referencedEntities()[0]->getValidations();
  }
  $entity->save();
  $stage = $entity->getStage();
  
}

// deletes field_store if validated_field is deleted
function validated_fields_validated_field_delete($entity){
  if(isSet($entity->storage->referencedEntities()[0])){
    $storage = $entity->storage->referencedEntities()[0]->delete();
  }
}

function validated_fields_validated_field_create($entity){
  $var = "test";
}

// when stage is posted, adds it to list of content_workflow stages in corresponding content_workflow entity
function validated_fields_stage_insert($entity){
  $workflow = $entity->get("content_workflow")->entity;
  $workflow_stages = $workflow->stages;
  for($i = 0; $i<$workflow_stages; $i++){
    if($workflow_stages->offsetGet($i)->target_id == $entity->id()){
      return;
    }
  }
  $workflow_stages->appendItem($entity);
  $workflow->save();
}

function validated_fields_stage_instance_presave($entity){

  
  // automatically sets due dates based on start dates
  if(!isSet($entity->start_date->value)){
    $entity->set("start_date", $entity->estimated_start_date->value);
  }
  
  if(($entity->estimated_start_date->value != $entity->original->estimated_start_date->value) && ($entity->estimated_due_date->value == $entity->original->estimated_due_date->value)){
    $entity->setEstimatedDueFromStart();
  }
  if(($entity->start_date->value != $entity->original->start_date->value) && ($entity->due_date->value == $entity->original->due_date->value)){
    $entity->setDueFromStart();
  }
}

// attaches stage instance to stage template. The stage instance must be posted with a stage_template
function validated_fields_stage_instance_insert($entity){
  $stage_template = $entity->get("stage_template")->entity;
  $stage_template_stages = $stage_template->stage_instances;
  for($i = 0; $i<$stage_template_stages; $i++){
    if($stage_template_stages->offsetGet($i)->target_id == $entity->id()){
      return;
    }
  }
  $stage_template_stages->appendItem($entity);
  $stage_template->save();
}

